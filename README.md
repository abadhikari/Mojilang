# EmoLang ğŸ‘»

EmoLang (EmojiLanguage ğŸ˜‰) is a simple programming language that utilizes emojis and is built from scratch with a custom lexer, parser, and interpreter. 
My goal with EmoLang was to learn the basic inner workings of a programming language while also making a fun goofy programming language using emojis for common programming constructs like variables, loops, and conditionals.
It's currently written in Python which will be terribly slow but I wanted to create a quick prototype before deciding if I wanted to sink weeks into creating it in C ğŸ˜®â€ğŸ’¨.

## Table of Contents
- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
- [Syntax](#syntax)
- [Example](#example)
- [How It Works](#how-it-works)
  - [Lexer](#lexer)
  - [Parser](#parser)
  - [Interpreter](#interpreter)
- [License](#license)

## Features
- ğŸ™ˆ Emoji-based syntax
- ğŸ˜¤ Custom lexer, parser, and interpreter
- ğŸ¦ Basic programming features: variables, loops, conditionals, and functions
- ğŸ—£ï¸ Built-in `print` functionality

## Installation
To run EmoLang, youâ€™ll need Python 3.6+ installed on your machine. You can clone this repository and run the interpreter directly.

1. Clone the repository:
   ```bash
   git clone https://github.com/abadhikari/EmoLang.git
   ```

## Usage
To run an EmoLang program, follow these steps:

1. Write your EmoLang code in a `.emo` file using the emoji-based syntax.

2. Run the interpreter on your `.emo` file using the following command from the project root directory:
   ```bash
   python -m emolang.main path/to/your/file.emo

## Syntax
EmoLang uses emojis to represent common programming constructs. Below is an overview of the syntax:

1. **Variables**
 
Define variables using the ğŸ¥¸ emoji, followed by the variable name, the assignment emoji âœï¸, a value, and semicolon (all statements must end in a semicolon):
```
ğŸ¥¸ variable âœï¸ 5;
```

2. Print Statements
The ğŸ—£ï¸ emoji is used for printing output:
```
ğŸ—£ï¸("Hello, World!");
```

3. **If Statements**

The ğŸ¤” emoji is used for if statements, ğŸ™ˆ is used for else if, ğŸ’… is used for else, ğŸ˜¤ is the equivalent of true while ğŸ˜” is the equivalent of false. 
```
ğŸ¤”(ğŸ˜¤) {
    ğŸ—£ï¸("This is true.");
} ğŸ’… {
    ğŸ—£ï¸("This is false.");
}
```

4. **Loops**
The ğŸ” emoji is used for loops, ğŸ’¥ is for break, and ğŸ¤“ is for continue. 
```
ğŸ¥¸ i âœï¸ 10;
ğŸ”(i â˜ï¸ 0) {
    ğŸ—£ï¸(i);
    i âœï¸ i â– 1;
}
ğŸ—£ï¸("Blast off!");
```

5. **Example**

Here's an example utilizing several constructs from above:
```
ğŸ¥¸ age âœï¸ 20;
ğŸ¤”(age â˜ï¸ 21) {
    ğŸ—£ï¸("You can drink ğŸ˜¤!");
} ğŸ™ˆ(age ğŸ¤ 20) {
    ğŸ—£ï¸("You're so close but you still can't drink ğŸ˜©!");
} ğŸ’… {
    ğŸ—£ï¸("You can't drink ğŸ˜”!");
}
```

## How It Works
EmoLang consists of three main components: the lexer, parser, and interpreter.

**Lexer**: Converts the raw source code into tokens.
**Parser**: Takes the tokens and organizes them into an Abstract Syntax Tree (AST) using the rescursive descent parsing algorithm.
**Interpreter**: Walks through the AST and executes the program by evaluating each node, handling expressions, statements, etc.

### Lexer
The lexer is responsible for converting raw source code into a list of tokens. A token is a logic unit of the code, such as a number, an operator, or a keyword. The lexer scans each character of the source code and converts them into tokens.

For example:
```
ğŸ¥¸ variable âœï¸ 5;
```
This is converted by the lexer into the following tokens:

* VAR (ğŸ¥¸)
* IDENTIFIER (variable)
* EQUAL (âœï¸)
* NUMBER (5)
* SEMI_COLON (;)

### Parser
The parser takes the tokens produced by the lexer and organizes them into an Abstract Syntax Tree (AST). The AST is a hierarchical structure that represents the syntactical structure of the EmoLang program.

For example:

```
ğŸ¥¸ variable âœï¸ 5 â• 3;
```

This is parsed into an AST node representing an assignment of the value 5 + 3 to the variable variable which would look like

```
AssignmentNode
 â”œâ”€â”€ VariableNode ("variable")
 â””â”€â”€ AdditionNode
     â”œâ”€â”€ NumberLiteralNode (5)
     â””â”€â”€ NumberLiteralNode (3)
```

The parser ensures that the syntax of the program is correct. If any syntax violations occur (such as missing semicolons or invalid expressions), then the parser raises a SyntaxExceptoin.

### Interpreter
The interpreter is responsible for executing the Abstract Syntax Tree (AST) generated by the parser. The interpreter evaluates each node of the AST, executing statements and expressions in the correct order.
Currently, it's very simple since all it has to do is run evaluate method of the root node ğŸ˜‰.

For example:

```
ğŸ¥¸ x âœï¸ 10 â• 20;
ğŸ—£ï¸(x);
```
The interpreter will:

1. Evaluate 10 + 20 and assign the result (30) to x.
1. Print the value of x to the console (resulting in 30 being displayed).
The interpreter handles all the logic and operations defined by EmoLang, such as variable assignments, conditionals, loops, and function calls (these are still in-progress).

## License
This project is licensed under the MIT License - see the LICENSE file for details.
